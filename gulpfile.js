var // Modules
	gulp = require('gulp'),
	g = require('gulp-load-plugins')(),

	sh = require('child_process'),
	fs = require('fs'),

	args = require('yargs').argv,
	bsync = require('browser-sync').create(),
	del = require('del'),
	json2php = require('json2php'),
	named = require('vinyl-named'),
	path = require('path'),
	po2json = require('po2json'),
	util = require('util'),
	webpack = require('webpack-stream');

var paths = {
	src: {
		js: 'src/js',
		less: 'src/less',
		images: 'src/images'
	},
	js: 'js',
	css: '.',
	images: 'images',
	lang: 'languages'
};

var pkg = require('./package.json');

var mode = {
	clean: args.c || args.clean,
	dev: !args.release
};

gulp.task('default', ['build']);
gulp.task('build', ['build:js', 'build:css', 'build:images', 'build:lang']);

/**
 * Builds scripts
 */
gulp.task('build:js', ['build:js:clean', 'build:js:pack'], function () {
	return gulp.src(paths.js + '/**/*.js')
		.pipe(g.if(mode.dev, g.sourcemaps.init()))
		.pipe(g.uglify({preserveComments: 'some'}))
		.pipe(g.if(mode.dev, g.sourcemaps.write()))
		.pipe(g.rename({extname: '.min.js'}))
		.pipe(gulp.dest(paths.js))
		.pipe(bsync.stream({match: '**/*.js'}));
});

/**
 * Cleans up scripts
 */
gulp.task('build:js:clean', function (done) {
	return del([paths.js + '/**/*'], done);
});

/**
 * Bundles multiple scripts
 */
gulp.task('build:js:pack', function () {
	return gulp.src(paths.src.js + '/{main,ie-polyfill}.js')
		.pipe(g.plumber({
			errorHandler: function (e) {
				console.log(e.messageFormatted);
				this.emit('end');
			}
		}))
		.pipe(named())
		.pipe(webpack({
			// Webpack options
			resolve: { // Path resolver
				root: [path.join(__dirname)],
				alias: {
					'bower': 'bower_components'
				}
			}
		}))
		.pipe(gulp.dest(paths.js));
});

/**
 * Builds CSSes
 */
gulp.task('build:css', ['build:css:less'], function () {
	return gulp.src(paths.css + '/*.css')
		.pipe(g.if(!mode.dev, g.cleanCss({
			keepSpecialComments: '*',
			compatibility: 'ie9'
		})))
		.pipe(gulp.dest(paths.css))
		.pipe(bsync.stream({match: '**/*.css'}));
});

/**
 * Compiles Less sources into CSSes
 */
gulp.task('build:css:less', ['build:images'], function () {
	return gulp.src(paths.src.less + '/{style,editor-style,ie-style}.less')
		.pipe(g.plumber({
			errorHandler: function (e) {
				console.error(e);
				this.emit('end');
			}
		}))
		.pipe(g.if(mode.dev, g.sourcemaps.init()))
		.pipe(g.less()) // Compile Less
		.pipe(g.autoprefixer({
			browsers: ['last 3 versions', 'ie >= 9']
		}))
		.pipe(g.if(mode.dev, g.sourcemaps.write()))
		.pipe(g.rename({extname: '.css'})) // Rename *.less to *.css
		.pipe(gulp.dest(paths.css));
});

/**
 * Optimizes images
 */
gulp.task('build:images', mode.clean ? ['build:images:clean'] : null, function () {
	return gulp.src(paths.src.images + '/**/*')
		.pipe(g.changed(paths.images))
		.pipe(g.imagemin({
			progressive: true,
			svgoPlugins: [{removeViewBox: false}]
		}))
		.pipe(gulp.dest(paths.images));
});

/**
 * Cleans up images
 */
gulp.task('build:images:clean', function (done) {
	return del([paths.images + '/**/*'], done);
});

/**
 * Builds language files
 */
gulp.task('build:lang', ['build:lang:mo', 'build:lang:php']);

/**
 * Builds compiled language files
 */
gulp.task('build:lang:mo', ['build:lang:po'], function () {
	return gulp.src(paths.lang + '/**/*.po')
		.pipe(g.gettext()) // Compile *.po into *.mo
		.pipe(gulp.dest(paths.lang));
});

/**
 * Composes PHP translation tables from *.po files
 */
gulp.task('build:lang:php', ['build:lang:po'], function () {
	var dest = paths.lang;
	var ext = '.php';
	return gulp.src(paths.lang + '/**/*.po')
		.pipe(g.changed(dest, {extension: ext}))
		.pipe(g.transform(function (content) {
			var parsed = po2json.parse(content, {stringify: false, format: 'mf'});
			delete parsed[""]; // Remove unnecessary data
			var code = '$translations = ' + json2php(parsed);
			var msg = 'DO NOT EDIT this file! The code is generated from {locale}.po file by Gulp';
			return `<?php /* ${msg} */${code}`;
		}))
		.pipe(g.rename({extname: ext}))
		.pipe(gulp.dest(dest));
});

/**
 * Builds translation files
 * TODO: Respect pkg.translations variable
 */
gulp.task('build:lang:po', ['build:lang:po:ja']);

/**
 * Builds Japanese translation file
 * TODO: Integrate into build:lang:po task
 * TODO: If 'ja.po' does not exist, clone it from '{textdomain}.pot'
 */
gulp.task('build:lang:po:ja', ['build:lang:pot'], function (done) {
	sh.exec(`gettext-merge --po=${paths.lang}/ja.po --pot=${paths.lang}/${pkg.textdomain}.pot`, function (error, stdout, stderr) {
		if (error !== null) console.error(error);
		else console.log(stdout);
		done();
	});
});

/**
 * Builds translation template (*.pot)
 */
gulp.task('build:lang:pot', function () {
	return gulp.src(['./*.php', 'parts/**/*.php', 'lib/**/*.php', 'style.css'])
		.pipe(g.wpPot({
			domain: pkg.textdomain,
			destFile: `${pkg.textdomain}.pot`
		}))
		.pipe(gulp.dest(paths.lang));
});

/**
 * Watch & Preview
 */
gulp.task('watch', ['build'], function () {
	bsync.init({proxy: pkg.devUrl});
	gulp.watch(paths.src.js + '/**/*.js', ['build:js']);
	gulp.watch(paths.src.less + '/**/*.less', ['build:css']);
	gulp.watch(paths.src.images + '/**/*', ['build:images']);
	gulp.watch(['./*.php', 'parts/**/*.php', 'lib/**/*.php'], ['build:lang']);
	gulp.watch(['./*.php', 'parts/**/*.php', 'lib/**/*.php', paths.lang + '/**/*.mo'])
		.on('change', bsync.reload);
});
